{
  "_metadata": {
    "bundle_id": "CMGT_SUB_WriteTaskDetails"
  },
  "objects": {
    "9248008e-2c2c-4eea-bb28-4a3c89838403": {
      "name": "CMGT_UTIL_RemoveRecordRelationshipsWithSingleKey_Reducer",
      "type": "Expression Rule",
      "sail_code": "if(\n  runtimetypeof(ri!key) <> 'type!{http://www.appian.com/ae/types/2009}RecordRelationship',\n  ri!record,\n  a!match(\n    value: index(ri!record, ri!key, null),\n    whenTrue: count(fv!value) = 1,\n    then: with(\n      local!indexedValue: index(\n        ri!record,\n        ri!key,\n        1,\n        index(ri!record, ri!key, null)\n      ),\n      local!subKeys: a!keys(local!indexedValue),\n      if(\n        length(local!subKeys) = 1,\n        remove(ri!record, ri!key),\n        #\"urn:appian:function:v1:a:update\"(\n          ri!record,\n          ri!key,\n          reduce(\n            rule!CMGT_UTIL_RemoveRecordRelationshipsWithSingleKey_Reducer(record: _, key: _),\n            local!indexedValue,\n            local!subKeys\n          )\n        )\n      )\n    ),\n    default: ri!record\n  )\n)"
    },
    "_a-0000eaa7-a5c0-8000-9c22-011c48011c48_973190": {
      "name": "CMGT_UTIL_MergeWriteRecordIdsToProcessVariable",
      "type": "Expression Rule",
      "sail_code": "/*\nThe main rule to merge the ID-output of a WriteRecords SS node back to the input process variable.\n\nSTANDARD USAGE:\n- Use this in tandem with rule CMGT_UTIL_DropNonWritableRelationshipsFromRecord (see that description)\n- In the output of a WriteRecords SS, do:\n  A - New Custom Output\n  B - rule!CMGT_UTIL_MergeWriteRecordIdsToProcessVariable(\n        processData: pv![the pv your wrote],\n        recordsUpdated: ac!RecordsUpdated,\n        fksToParent: {list of record fields that are FKs to the primary PK you wrote}\n      )\n  C - Save this back to the pv you wrote\n\nMAPPING FKS:\n- Using this rule in the current state, child-FKs can only be set \nwhere they map back to the primary record type, using input \"fksToParent\".\n  -> For example, if you are writing \"Case\", \n    - you could set \"Case.Comment.caseId\"\n    - you could set \"Case.Comment.Replies.caseId\"\n    - but not \"Case.Comment.Replies.commentId\" (since the FK \"commentId\" is not the PK of \"Case\")\n- To set other foreign keys, you would have to run manual update rules using the result of this.\nNote:\n- \"fksToParent\" is optimized for 1:M relationships.\n  - Setting an fkToParent for a 1:1 will create an instance of that child record if it is null.\n\nIMPORTANT GENERAL NOTES: \n- The result of THIS rule will have data that IS considered changed, \nso a designer should be cautious about re-writing this later in process \nas it could cause race condition and performance side affects.\n\n- Also, the result of this WILL NOT have custom-fields calculated, \nsince they can be changed as a result of the write, but this rule is not re-querying.\nIf you need these, then re-query.\n\n- This should generally only be used for downstream flows that don't write it directly again, \nsuch as document processing, emails, etc.\n*/\nif(\n  or(\n    runtimetypeof(ri!recordsUpdated) = runtimetypeof(a!flatten(ri!recordsUpdated)),\n    runtimetypeof(ri!recordsUpdated) = 'type!{http://www.appian.com/ae/types/2009}Variant?list'\n  ),\n  if(\n    count(a!flatten(ri!recordsUpdated)) = 0,\n    ri!processData,\n    #\"SYSTEM_SYSRULES_forEach\"(\n      items: enumerate(count(a!flatten(ri!recordsUpdated))),\n      expression: rule!CMGT_UTIL_MergeWriteRecordIdsToProcessVariable(\n        processData: a!flatten(ri!processData)[fv!index],\n        recordsUpdated: cast(\n          runtimetypeof(a!flatten(ri!processData)),\n          ri!recordsUpdated\n        )[fv!index],\n        fksToParent: ri!fksToParent\n      )\n    )\n  ),\n  a!localVariables(\n    local!keys: #\"SYSTEM_SYSRULES_forEach\"(\n      items: a!keys(ri!recordsUpdated),\n      expression: a!map(\n        key: fv!item,\n        isPrimaryKey: runtimetypeof(fv!item) = 'type!{http://www.appian.com/ae/types/2009}RecordField'\n      )\n    ),\n    local!keysOrganized: rule!CMGT_UTIL_Filter(\n      records: local!keys,\n      field: \"isPrimaryKey\",\n      value: true,\n      filterType: \"FULL_RESULT\"\n    ),\n    local!primaryKeyField: local!keysOrganized.firstMatch.key,\n    local!updates: rule!CMGT_UTIL_SetRecordFields(\n      record: ri!processData,\n      neverOverwrite: {\n        a!map(\n          field: local!primaryKeyField,\n          value: ri!recordsUpdated[local!primaryKeyField]\n        ),\n        #\"SYSTEM_SYSRULES_forEach\"(\n          items: ri!fksToParent,\n          expression: a!map(\n            field: fv!item,\n            value: ri!recordsUpdated[local!primaryKeyField],\n            /*Children get complicated, and an update should only run if a child is actually attached*/\n            applyWhen: a!match(\n              value: runtimetypeof(ri!processData[fv!item]),\n              equals: runtimetypeof(a!flatten(ri!processData[fv!item])),\n              then: count(ri!processData[fv!item]) > 0,\n              equals: tointeger(\n                'type!{http://www.appian.com/ae/types/2009}Variant?list'\n              ),\n              then: or(\n                #\"SYSTEM_SYSRULES_forEach\"(\n                  items: ri!processData[fv!item],\n                  expression: a!isNotNullOrEmpty(fv!item)\n                )\n              ),\n              default: a!isNotNullOrEmpty(ri!processData[fv!item])\n            )\n          )\n        )\n      },\n      childRelationships: #\"SYSTEM_SYSRULES_forEach\"(\n        items: local!keysOrganized.rejects,\n        expression: a!map(\n          field: fv!item.key,\n          value: if(\n            rule!CMGT_UTIL_IsBlank(ri!processData[fv!item.key]),\n            ri!recordsUpdated[fv!item.key],\n            rule!CMGT_UTIL_MergeWriteRecordIdsToProcessVariable(\n              processData: ri!processData[fv!item.key],\n              recordsUpdated: ri!recordsUpdated[fv!item.key],\n              fksToParent: {}\n            )\n          )\n        )\n      )\n    ),\n    /*reduce over updates to remove any relationships that were incorrectly created with just an fk*/\n    if(\n      a!isNullOrEmpty(ri!fksToParent),\n      local!updates,\n      reduce(\n        rule!CMGT_UTIL_RemoveRecordRelationshipsWithSingleKey_Reducer(record: _, key: _),\n        local!updates,\n        a!keys(local!updates)\n      )\n    )\n  )\n)"
    },
    "_a-0000e9d3-70bf-8000-9bbd-011c48011c48_180568": {
      "name": "CMGT_UTIL_IsNotBlank",
      "type": "Expression Rule",
      "sail_code": "not(rule!CMGT_UTIL_IsBlank(ri!input))"
    },
    "_a-0000eab0-e049-8000-9c27-011c48011c48_1007763": {
      "name": "CMGT_Task_WriteRecordsProperties",
      "type": "Expression Rule",
      "sail_code": "if(\n  ri!isInput,\n  rule!CMGT_UTIL_DropNonWritableRelationshipsFromRecord(\n    records: ri!tasks,\n    relationships: {\n      recordType!CMGT_Task.beforeTaskInstanceBranches,\n      recordType!CMGT_Task.milestone,\n      recordType!CMGT_Task.selectedTaskResponseOption,\n      /*Do not write comments because we need to write documents      */\n      recordType!CMGT_Task.comments,\n      recordType!CMGT_Task.status\n    }\n  ),\n  rule!CMGT_UTIL_MergeWriteRecordIdsToProcessVariable(\n    processData: ri!tasks,\n    recordsUpdated: ri!recordsUpdated,\n    fksToParent: {\n      recordType!CMGT_Task.comments.taskId,\n      recordType!CMGT_Task.documents.taskId,\n      recordType!CMGT_Task.roles.taskId,\n      recordType!CMGT_Task.taskResponseOptions.taskId,\n      recordType!CMGT_Task.selectedTaskResponseOption.taskId,\n      recordType!CMGT_Task.conditionSet.taskId,\n      recordType!CMGT_Task.createCaseTask.taskId,\n      recordType!CMGT_Task.sendEmailTask.taskId\n    }\n  )\n)"
    },
    "_a-0000e990-c462-8000-9ba7-011c48011c48_25461": {
      "name": "CMGT_Task_SetMetaData",
      "type": "Expression Rule",
      "sail_code": "a!localVariables(\n  local!originalTasks: if(\n    or(\n      rule!CMGT_UTIL_IsBlank(ri!tasks),\n      ri!eventType = \"TRIGGERED_AUTOMATION_ACTION\",\n      \n    ),\n    null,\n    rule!CMGT_QR_GetTask(\n      taskId: ri!tasks[recordType!CMGT_Task.taskId],\n      includeInactive: true,\n      executeWhen: rule!CMGT_UTIL_IsNotBlank(\n        a!flatten(\n          ri!tasks[recordType!CMGT_Task.taskId]\n        )\n      ),\n      fields: {\n        recordType!CMGT_Task.roles,\n        recordType!CMGT_Task.conditionSet\n      }\n    )\n  ),\n  rule!CMGT_Task_SetEvents(\n    tasks: #\"SYSTEM_SYSRULES_forEach\"(\n      items: ri!tasks,\n      expression: a!localVariables(\n        /*The current value of this record in the database*/\n        local!orgItem: rule!CMGT_UTIL_Filter(\n          records: local!originalTasks,\n          field: recordType!CMGT_Task.taskId,\n          value: fv!item[recordType!CMGT_Task.taskId]\n        ),\n        rule!CMGT_UTIL_SetRecordFields(\n          record: fv!item,\n          /*Always set these fields with each update*/\n          alwaysOverwrite: {\n            a!map(\n              field: recordType!CMGT_Task.modifiedBy,\n              value: if(\n                /*we want the modified by to be process automation only when the new instance is created*/\n                and(\n                  rule!CMGT_UTIL_IsBlank(\n                    fv!item[recordType!CMGT_Task.taskId]\n                  ),\n                  tointeger(\n                    fv!item[recordType!CMGT_Task.instanceCount]\n                  ) > 1\n                ),\n                cons!CMGT_TXT_PROCESS_AUTOMATION,\n                ri!initiator\n              )\n            ),\n            a!map(\n              field: recordType!CMGT_Task.modifiedOn,\n              value: now()\n            ),\n            if(\n              ri!eventType = cons!CMGT_TXT_EVENT_TYPE_TASK_MODIFY_CHILD_RECORD,\n              null,\n              {\n                a!map(\n                  field: recordType!CMGT_Task.statusId,\n                  value: fv!item[recordType!CMGT_Task.statusId],\n                  applyWhen: contains(\n                    {\n                      cons!CMGT_REFID_STATUS_TASK_READY,\n                      cons!CMGT_REFID_STATUS_TASK_IN_PROGRESS\n                    },\n                    tointeger(\n                      fv!item[recordType!CMGT_Task.statusId]\n                    )\n                  )\n                ),\n                /* Calculate dueOn based on SLA*/\n                a!map(\n                  field: recordType!CMGT_Task.dueOn,\n                  value: if(\n                    or(\n                      tointeger(\n                        fv!item[recordType!CMGT_Task.statusId]\n                      ) = cons!CMGT_REFID_STATUS_TASK_READY,\n                      tointeger(\n                        fv!item[recordType!CMGT_Task.statusId]\n                      ) = cons!CMGT_REFID_STATUS_TASK_IN_PROGRESS\n                    ),\n                    if(\n                      and(\n                        or(\n                          rule!CMGT_UTIL_IsBlank(\n                            value: local!orgItem[recordType!CMGT_Task.dueOn]\n                          ),\n                          tointeger(\n                            local!orgItem[recordType!CMGT_Task.statusId]\n                          ) = cons!CMGT_REFID_STATUS_TASK_COMPLETED,\n                          tointeger(\n                            local!orgItem[recordType!CMGT_Task.statusId]\n                          ) = cons!CMGT_REFID_STATUS_TASK_NOT_NEEDED\n                        ),\n                        /*  For open and reopen , dueOn is updated as null in the recordAction context*/\n                        rule!CMGT_UTIL_IsBlank(\n                          value: fv!item[recordType!CMGT_Task.dueOn]\n                        ),\n                        /* we should not update due on if the status is being swithced between ready and inprogress*/\n                        tointeger(\n                          fv!item[recordType!CMGT_Task.statusId]\n                        ) <> tointeger(\n                          local!orgItem[recordType!CMGT_Task.statusId]\n                        ),\n                        if(\n                          tointeger(\n                            fv!item[recordType!CMGT_Task.statusId]\n                          ) = cons!CMGT_REFID_STATUS_TASK_IN_PROGRESS,\n                          tointeger(\n                            local!orgItem[recordType!CMGT_Task.statusId]\n                          ) <> cons!CMGT_REFID_STATUS_TASK_READY,\n                          not(\n                            and(\n                              tointeger(\n                                local!orgItem[recordType!CMGT_Task.statusId]\n                              ) = cons!CMGT_REFID_STATUS_TASK_IN_PROGRESS,\n                              tointeger(\n                                fv!item[recordType!CMGT_Task.statusId]\n                              ) = cons!CMGT_REFID_STATUS_TASK_READY\n                            )\n                          )\n                        )\n                      ),\n                      rule!CMGT_UTIL_CalculateDueDateBasedOnSLA(\n                        SLA: fv!item[recordType!CMGT_Task.sla],\n                        dateTime: now()\n                      ),\n                      fv!item[recordType!CMGT_Task.dueOn]\n                    ),\n                    fv!item[recordType!CMGT_Task.dueOn]\n                  )\n                ),\n                /*Clear completedBy/On whenever the statusId goes back to Queued/Ready/Inprogress status*/\n                a!map(\n                  field: recordType!CMGT_Task.completedBy,\n                  value: null,\n                  applyWhen: contains(\n                    {\n                      cons!CMGT_REFID_STATUS_TASK_IN_PROGRESS,\n                      cons!CMGT_REFID_STATUS_TASK_READY,\n                      cons!CMGT_REFID_STATUS_TASK_QUEUED,\n                      \n                    },\n                    tointeger(\n                      fv!item[recordType!CMGT_Task.statusId]\n                    )\n                  )\n                ),\n                /*Task has not been completed so no date should be available*/\n                a!map(\n                  field: recordType!CMGT_Task.completedOn,\n                  value: null,\n                  applyWhen: contains(\n                    {\n                      cons!CMGT_REFID_STATUS_TASK_IN_PROGRESS,\n                      cons!CMGT_REFID_STATUS_TASK_READY,\n                      cons!CMGT_REFID_STATUS_TASK_QUEUED,\n                      \n                    },\n                    tointeger(\n                      fv!item[recordType!CMGT_Task.statusId]\n                    )\n                  )\n                ),\n                a!map(\n                  field: recordType!CMGT_Task.isCurrent,\n                  value: a!defaultValue(\n                    fv!item[recordType!CMGT_Task.isCurrent],\n                    true\n                  ),\n                  \n                ),\n                a!map(\n                  field: recordType!CMGT_Task.instanceCount,\n                  value: a!defaultValue(\n                    fv!item[recordType!CMGT_Task.instanceCount],\n                    1\n                  ),\n                  \n                ),\n                \n              }\n            )\n          },\n          /*Only modify these fields if they are currently null*/\n          neverOverwrite: if(\n            ri!eventType = cons!CMGT_TXT_EVENT_TYPE_TASK_MODIFY_CHILD_RECORD,\n            {},\n            {\n              a!map(\n                field: recordType!CMGT_Task.createdBy,\n                value: ri!initiator\n              ),\n              a!map(\n                field: recordType!CMGT_Task.createdOn,\n                value: now()\n              ),\n              a!map(\n                field: recordType!CMGT_Task.isActive,\n                value: true\n              ),\n              a!map(\n                field: recordType!CMGT_Task.taskUuid,\n                value: rule!CMGT_UTIL_GenerateUuid_NonPlugin()\n              ),\n              a!map(\n                field: recordType!CMGT_Task.taskInstanceUuid,\n                value: rule!CMGT_UTIL_GenerateUuid_NonPlugin()\n              ),\n              a!map(\n                field: recordType!CMGT_Task.isAdHoc,\n                value: false,\n                \n              ),\n              /*Default status to \"Queued\"*/\n              a!map(\n                field: recordType!CMGT_Task.statusId,\n                value: cons!CMGT_REFID_STATUS_TASK_QUEUED\n              ),\n              /*Automatically calculate availableOn whenever the statusId is Ready*/\n              a!map(\n                field: recordType!CMGT_Task.availableOn,\n                value: now(),\n                applyWhen: tointeger(\n                  fv!item[recordType!CMGT_Task.statusId]\n                ) = cons!CMGT_REFID_STATUS_TASK_READY\n              ),\n              /*Set completedBy/On whenever the statusId matches a Completion status*/\n              a!map(\n                field: recordType!CMGT_Task.completedBy,\n                value: ri!initiator,\n                applyWhen: contains(\n                  {\n                    cons!CMGT_REFID_STATUS_TASK_COMPLETED,\n                    cons!CMGT_REFID_STATUS_TASK_NOT_NEEDED\n                  },\n                  tointeger(\n                    fv!item[recordType!CMGT_Task.statusId]\n                  )\n                )\n              ),\n              a!map(\n                field: recordType!CMGT_Task.completedOn,\n                value: now(),\n                applyWhen: contains(\n                  {\n                    cons!CMGT_REFID_STATUS_TASK_COMPLETED,\n                    cons!CMGT_REFID_STATUS_TASK_NOT_NEEDED\n                  },\n                  tointeger(\n                    fv!item[recordType!CMGT_Task.statusId]\n                  )\n                )\n              ),\n              a!map(\n                field: recordType!CMGT_Task.taskIntentionCode,\n                value: cons!CMGT_WFL_CASE_TYPE_TASK_INTENTION_CODE_WORKFLOW\n              )\n            }\n          ),\n          /*Set metadata for all child relationships*/\n          childRelationships: {\n            a!map(\n              field: recordType!CMGT_Task.roles,\n              value: rule!CMGT_Role_SetMetaData(\n                roles: fv!item[recordType!CMGT_Task.roles],\n                initiator: ri!initiator\n              )\n            ),\n            a!map(\n              field: recordType!CMGT_Task.comments,\n              value: rule!CMGT_Comment_SetMetaData(\n                /*Note that the caseId context is on task, therefore we need to set it on comment here*/\n                comments: rule!CMGT_UTIL_SetForeignKey(\n                  records: fv!item,\n                  relationship: recordType!CMGT_Task.comments,\n                  parentPkField: recordType!CMGT_Task.caseId,\n                  childFkField: recordType!CMGT_Comment.caseId\n                ),\n                initiator: ri!initiator\n              )\n            ),\n            a!map(\n              field: recordType!CMGT_Task.documents,\n              value: rule!CMGT_Document_SetMetaData(\n                /*Note that the caseId context is on task, therefore we need to set it on document here*/\n                documents: rule!CMGT_UTIL_SetForeignKey(\n                  records: fv!item,\n                  relationship: recordType!CMGT_Task.documents,\n                  parentPkField: recordType!CMGT_Task.caseId,\n                  childFkField: recordType!CMGT_Document.caseId\n                ),\n                initiator: ri!initiator\n              )\n            ),\n            a!map(\n              field: recordType!CMGT_Task.beforeTaskInstanceBranches,\n              value: rule!CMGT_TaskBranch_SetMetaData(\n                taskBranches: fv!item[recordType!CMGT_Task.beforeTaskInstanceBranches]\n              )\n            ),\n            a!map(\n              field: recordType!CMGT_Task.taskResponseOptions,\n              value: rule!CMGT_TaskResponseOption_SetMetaData(\n                taskResponseOptions: fv!item[recordType!CMGT_Task.taskResponseOptions]\n              )\n            ),\n            a!map(\n              field: recordType!CMGT_Task.conditionSet,\n              value: rule!CMGT_ConditionSet_SetMetaData(\n                conditionSets: fv!item[recordType!CMGT_Task.conditionSet],\n                initiator: ri!initiator\n              )\n            ),\n            a!map(\n              field: recordType!CMGT_Task.createCaseTask,\n              value: rule!CMGT_CreateCaseTask_SetMetaData(\n                createCaseTask: fv!item[recordType!CMGT_Task.createCaseTask],\n                initiator: ri!initiator\n              ),\n              applyWhen: rule!CMGT_UTIL_IsNotBlank(\n                fv!item[recordType!CMGT_Task.createCaseTask]\n              )\n            ),\n            a!map(\n              field: recordType!CMGT_Task.taskCaseMap,\n              value: rule!CMGT_TaskCaseMap_SetMetaData(\n                taskCaseMap: fv!item[recordType!CMGT_Task.taskCaseMap],\n                initiator: ri!initiator\n              ),\n              applyWhen: rule!CMGT_UTIL_IsNotBlank(\n                fv!item[recordType!CMGT_Task.taskCaseMap]\n              )\n            ),\n            a!map(\n              field: recordType!CMGT_Task.sendEmailTask,\n              value: rule!CMGT_SendEmailTask_SetMetaData(\n                sendEmailTask: fv!item[recordType!CMGT_Task.sendEmailTask],\n                initiator: ri!initiator\n              ),\n              applyWhen: rule!CMGT_UTIL_IsNotBlank(\n                fv!item[recordType!CMGT_Task.sendEmailTask]\n              )\n            ),\n            a!map(\n              field: recordType!CMGT_Task.automationWorkflowTasks,\n              value: rule!CMGT_Task_SetMetaData(\n                tasks: fv!item[recordType!CMGT_Task.automationWorkflowTasks],\n                initiator: cons!CMGT_TXT_PROCESS_AUTOMATION,\n                eventType: \"TRIGGERED_AUTOMATION_ACTION\"\n              ),\n              applyWhen: rule!CMGT_UTIL_IsNotBlank(\n                fv!item[recordType!CMGT_Task.automationWorkflowTasks]\n              )\n            ),\n            a!map(\n              field: recordType!CMGT_Task.automationTaskAction,\n              value: rule!CMGT_TaskAction_SetMetaData(\n                taskAction: fv!item[recordType!CMGT_Task.automationTaskAction],\n                initiator: ri!initiator\n              ),\n              applyWhen: rule!CMGT_UTIL_IsNotBlank(\n                fv!item[recordType!CMGT_Task.automationTaskAction]\n              )\n            )\n          }\n        )\n      )\n    ),\n    originalTasks: local!originalTasks,\n    initiator: ri!initiator,\n    eventType: ri!eventType,\n    taskBranches: ri!taskBranches\n  )\n)"
    },
    "0007ed56-f27b-8000-1f6f-7f0000014e7a": {
      "name": "CMGT_SUB_CopyAndUpdateEmailAttachments",
      "type": "Process Model",
      "sail_code": "// Input: ?\n= pv!case[recordType!CMGT_Case.folderId]\n\n// Input: ?\n=\"Case \" & pv!case[recordType!CMGT_Case.friendlyId] & \" \" & cons!CMGT_TXT_EMAIL_TEMPLATE_ATTACHMENTS\n\n// Output: ?\nAC!NewFolder\n\n// Input: ?\n= index( pv!attachmentsToCopy[tp!instanceindex], recordType!CMGT_EmailTemplateAttachments.appianDocumentId, null())\n\n// Input: ?\n= pv!emailTemplateAttachmentsFolder\n\n// Output: ?\nappian:record-field:v1:ecfa3aa5-8852-4685-8d4c-f54e1a112163/dbc63d9c-19eb-4a09-9b69-bdd901e11974\"][tp!instanceindex]:document(ac!newDocument, \"id\")\n\n// Input: ?\n= index( pv!attachmentsToMove[tp!instanceindex], recordType!CMGT_EmailTemplateAttachments.appianDocumentId, null())\n\n// Input: ?\n=pv!emailTemplateAttachmentsFolder\n\n// Input: ?\n=pv!attachmentsToCopy\n\n// Input: ?\n=recordType!CMGT_EmailTemplateAttachments\n\n// Output: ?\na!localVariables(\n  local!folder: rule!CMGT_UTIL_GetSubFolderByType(\n    parentFolderId: pv!case[recordType!CMGT_Case.folderId],\n    folderType: cons!CMGT_TXT_EMAIL_TEMPLATE_ATTACHMENTS\n  ),\n  if(\n    tointeger(local!folder) = tointeger(\n      pv!case[recordType!CMGT_Case.folderId]\n    ),\n    null(),\n    local!folder\n  )\n)"
    },
    "_a-0000eab0-e049-8000-9c27-011c48011c48_1011527": {
      "name": "CMGT_UTIL_DropNonWritableRelationshipsFromRecord",
      "type": "Expression Rule",
      "sail_code": "/*\nThe main rule to \"cleanse\" the input of a WriteRecords SS node to remove non-writable relationships.\n\nSTANDARD USAGE:\n- Use this in tandem with rule CMGT_UTIL_MergeWriteRecordIdsToProcessVariable (see that description)\n- In the input of a WriteRecords SS (NOT in a previous script task), do:\n  A - Expressionable input to \"Records\" intput\n  B - rule!CMGT_UTIL_DropNonWritableRelationshipsFromRecord(\n        records: pv![the pv to write],\n        relationships: {list of record relationships that are not allowed to be written}\n      )\n\nIMPORTANT GENERAL NOTES: \n- The reason to run this in the input of the WriteRecords SS instead of a previous script task\nis that, when used with CMGT_UTIL_MergeWriteRecordIdsToProcessVariable, you can maintain the relationships\nthat you had to drop before writing.\n  -> For example, if you are writing \"Case\" but it has a child-relationship \"Address\" that cannot be written,\n    - this will drop \"Address\" before attempting to write\n    - if the output is configured properly it will reattach \"Address\" in the output\n    - the overall result is that you basically ran the node as if \"Address\" was ignored, \n      so that you can use it later in the process flow\n*/\n#\"SYSTEM_SYSRULES_forEach\"(\n  items: a!flatten(ri!records),\n  expression: reduce(\n    rule!CMGT_UTIL_DropNonWritableRelationshipsFromRecord_Reducer(\n      record: _,\n      relationship: _\n    ),\n    fv!item,\n    ri!relationships\n  )\n)"
    },
    "_a-0000e9d3-70bf-8000-9bbd-011c48011c48_180481": {
      "name": "CMGT_UTIL_RejectBlank",
      "type": "Expression Rule",
      "sail_code": "cast(\n  runtimetypeof(a!flatten(ri!array)),\n  reject(a!isNullOrEmpty(_), a!flatten(ri!array))\n)"
    },
    "_a-0000e9e5-e5dd-8000-9bc7-011c48011c48_232566": {
      "name": "CMGT_UTIL_GetSubFolderByType",
      "type": "Expression Rule",
      "sail_code": "if(\n  a!isNullOrEmpty(ri!parentFolderId),\n  tofolder(null),\n  tofolder(\n    a!localVariables(\n      local!allFolders: #\"SYSTEM_SYSRULES_forEach\"(\n        items: {\n          ri!parentFolderId,\n          folder(ri!parentFolderId, \"folderChildren\")\n        },\n        expression: a!map(\n          name: folder(fv!item, \"name\"),\n          folderId: fv!item\n        )\n      ),\n      local!filterForType: index(\n        a!flatten(\n          #\"SYSTEM_SYSRULES_forEach\"(\n            items: local!allFolders,\n            expression: if(\n              search(ri!folderType, fv!item.name),\n              fv!item.folderId,\n              {}\n            )\n          )\n        ),\n        1,\n        null\n      ),\n      a!defaultValue(local!filterForType, ri!parentFolderId)\n    )\n  )\n)"
    },
    "af326a29-a1c8-4399-a28d-996f85819d9e": {
      "name": "CMGT_UTIL_Filter",
      "type": "Expression Rule",
      "sail_code": "with(\n  local!fieldValuePairs: a!defaultValue(\n    ri!fieldValuePairs,\n    apply(\n      rule!CMGT_UTIL_Filter_CreateFieldValuePair(\n        field: _,\n        value: ri!value,\n        allFields: a!flatten(ri!field)\n      ),\n      a!flatten(ri!field)\n    )\n  ),\n  local!matchingCriteria: a!defaultValue(\n    value: ri!matchingCriteria,\n    default: \"ALL\"\n  ),\n  local!matchType: a!defaultValue(value: ri!matchType, default: \"EXACT\"),\n  local!matchIndices: if(\n    a!isNullOrEmpty(a!flatten(ri!records)),\n    tointeger({}),\n    reduce(\n      rule!CMGT_UTIL_Filter_Reducer(\n        matchingCriteria: local!matchingCriteria,\n        previousIndices: _,\n        records: a!flatten(ri!records),\n        fieldValuePair: _,\n        matchType: local!matchType\n      ),\n      a!match(\n        value: local!matchingCriteria,\n        equals: \"ALL\",\n        then: enumerate(count(a!flatten(ri!records))) + 1,\n        equals: \"ANY\",\n        then: {},\n        default: fn!error(\n          \"Invalid matchingCriteria, must be one of: ALL, ANY\"\n        )\n      ),\n      local!fieldValuePairs\n    )\n  ),\n  local!rejectIndices: difference(\n    if(\n      a!isNullOrEmpty(ri!records),\n      tointeger({}),\n      enumerate(count(a!flatten(ri!records))) + 1\n    ),\n    local!matchIndices\n  ),\n  local!matches: cast(\n    runtimetypeof(ri!records),\n    index(ri!records, local!matchIndices, {})\n  ),\n  local!rejects: cast(\n    runtimetypeof(ri!records),\n    index(ri!records, local!rejectIndices, {})\n  ),\n  local!output: a!match(\n    value: a!defaultValue(ri!filterType, \"FILTER\"),\n    equals: \"FILTER\",\n    then: local!matches,\n    equals: \"REJECT\",\n    then: local!rejects,\n    equals: \"FIRST_MATCH\",\n    then: index(local!matches, 1, null),\n    equals: \"FIRST_REJECT\",\n    then: index(local!rejects, 1, null),\n    equals: \"MATCH_COUNT\",\n    then: count(local!matchIndices),\n    equals: \"REJECT_COUNT\",\n    then: count(local!rejectIndices),\n    equals: \"MATCH_INDICES\",\n    then: local!matchIndices,\n    equals: \"REJECT_INDICES\",\n    then: local!rejectIndices,\n    equals: \"FULL_RESULT\",\n    then: a!map(\n      matches: local!matches,\n      rejects: local!rejects,\n      firstMatch: index(local!matches, 1, null),\n      firstReject: index(local!rejects, 1, null),\n      matchCount: count(local!matchIndices),\n      rejectCount: count(local!rejectIndices),\n      matchIndices: local!matchIndices,\n      rejectIndices: local!rejectIndices\n    ),\n    default: fn!error(\n      \"Invalid filterType, must be one of: FILTER, REJECT, FIRST_MATCH, FIRST_REJECT, MATCH_COUNT, REJECT_COUNT, MATCH_INDICES, REJECT_INDICES, FULL_RESULT\"\n    )\n  ),\n  local!output\n)"
    },
    "000fed8c-cc2c-8000-21af-7f0000014e7a": {
      "name": "CMGT_SUB_WriteTaskDetails",
      "type": "Process Model",
      "sail_code": "// Output: ?\nrule!CMGT_Task_SetMetaData(\n  tasks: pv!tasks,\n  initiator: cons!CMGT_TXT_PROCESS_AUTOMATION,\n  eventType: \"OPEN_NEXT_TASK\"\n)\n\n// Input: ?\nrule!CMGT_Task_WriteRecordsProperties(\n  tasks: pv!tasks,\n  isInput: true\n)\n\n// Input: ?\n=recordType!CMGT_Task\n\n// Output: ?\nrule!CMGT_Task_WriteRecordsProperties(\n  recordsUpdated:ac!RecordsUpdated,\n  tasks: pv!tasks,\n  isInput: false\n)\n\n// Input: ?\nremove(\n  rule!CMGT_UTIL_RejectBlank(array: { pv!taskBranches }),\n  {\n    recordType!CMGT_TaskBranch.beforeTaskInstance,\n    recordType!CMGT_TaskBranch.afterTaskInstance\n  }\n)\n\n// Input: ?\n=recordType!CMGT_TaskBranch\n\n// Output: ?\na!flatten(\n  #\"SYSTEM_SYSRULES_forEach\"(\n    items: rule!CMGT_UTIL_Filter(\n      records: pv!tasks,\n      field: recordType!CMGT_Task.isCurrent,\n      value: true\n    ),\n    expression: if(\n      rule!CMGT_UTIL_IsBlank(\n        fv!item[recordType!CMGT_Task.sendEmailTask]\n      ),\n      {},\n      #\"urn:appian:function:v1:a:update\"(\n        fv!item[recordType!CMGT_Task.sendEmailTask],\n        recordType!CMGT_EmailTemplateAttachments.sendEmailTaskId,\n        fv!item[recordType!CMGT_Task.sendEmailTask.sendEmailTaskId]\n      )\n    )\n  )\n)\n\n// Input: ?\n= rule!CMGT_QR_GetCase(\n  caseId:pv!caseId,\n  fields: {\n    recordType!CMGT_Case.caseId,\n    recordType!CMGT_Case.folderId,\n    recordType!CMGT_Case.friendlyId\n  }\n)\n\n// Input: ?\n=emailTemplateAttachments"
    },
    "_a-0000e990-c462-8000-9ba7-011c48011c48_33778": {
      "name": "CMGT_UTIL_SetRecordFields",
      "type": "Expression Rule",
      "sail_code": "/*\nFuture enhancement ideas:\n1 Parameter to skip update if the field isn't present in the object\n--- This would also apply to nested fields, as in, don't set a relationship field if the entire relationship object isn't there because it will instantiate it\n2 Parameter to overwrite based on more enhanced logic\n3 Allow list types for the `value`\n4 Allow reuse to apply setting metadata for nested relationships, but using their own set metadata rule\n--- e.g. CMGT_Entity_SetMetaData can be used in both the Case process and the individual Entity process\n*/\nif(\n  a!isNullOrEmpty(ri!record),\n  ri!record,\n  a!localVariables(\n    local!allUpdates: rule!CMGT_UTIL_RejectBlank(a!flatten(\n      {\n        ri!alwaysOverwrite,\n        ri!childRelationships,\n        #\"SYSTEM_SYSRULES_forEach\"(\n          items: ri!neverOverwrite,\n          expression: #\"urn:appian:function:v1:a:update\"(\n            fv!item,\n            \"value\",\n            /*Specifically using this instead of a!defaultValue() to account for the `{null}` value*/\n            if(\n              rule!CMGT_UTIL_IsBlank(ri!record[fv!item.field]),\n              fv!item.value,\n              ri!record[fv!item.field]\n            )\n          )\n        )\n      }\n    )),\n    local!onlyChangedUpdates: a!flatten(\n      #\"SYSTEM_SYSRULES_forEach\"(\n        items: local!allUpdates,\n        expression: if(\n          or(\n            tostring(ri!record[fv!item.field]) = tostring(fv!item.value),\n            toboolean(fv!item.applyWhen) = false\n          ),\n          {},\n          fv!item\n        )\n      )\n    ),\n    if(\n      a!isNullOrEmpty(local!onlyChangedUpdates),\n      ri!record,\n      #\"urn:appian:function:v1:a:update\"(\n        data: ri!record,\n        index: local!onlyChangedUpdates.field,\n        value: local!onlyChangedUpdates.value\n      )\n    )\n  )\n)"
    },
    "_a-0000e990-c462-8000-9ba7-011c48011c48_25890": {
      "name": "CMGT_UTIL_IsBlank",
      "type": "Expression Rule",
      "sail_code": "length(a!flatten(ri!value)) = 0"
    },
    "_a-0000e98b-cfe0-8000-9ba5-011c48011c48_19509": {
      "name": "CMGT_QR_GetCase",
      "type": "Expression Rule",
      "sail_code": "rule!CMGT_UTIL_QueryRecord(\n  recordType: recordType!CMGT_Case,\n  returnType: ri!returnType,\n  triggerRefresh: ri!triggerRefresh,\n  executeWhen: ri!executeWhen,\n  filters: {\n    ri!additionalFilters,\n    #\"SYSTEM_SYSRULES_queryFilter\"(\n      field: recordType!CMGT_Case.caseId,\n      operator: \"in\",\n      value: ri!caseId\n    ),\n    #\"SYSTEM_SYSRULES_queryFilter\"(\n      field: recordType!CMGT_Case.dueOn,\n      operator: \">\",\n      value: rule!CMGT_UTIL_ConvertDatetoDatetime(\n        date: ri!dueOnDate - 1,\n        useSystemTimeZone: a!defaultValue(ri!useSystemTimeZoneForDueOn,true)\n      )\n    ),\n    #\"SYSTEM_SYSRULES_queryFilter\"(\n      field: recordType!CMGT_Case.dueOn,\n      operator: \"<=\",\n      value: rule!CMGT_UTIL_ConvertDatetoDatetime(\n        date: ri!dueOnDate,\n        useSystemTimeZone: a!defaultValue(ri!useSystemTimeZoneForDueOn,true)\n      )\n    )\n  },\n  logicalExpressions: ri!additionalLogicalExpression,\n  fields: {\n    ri!fields,\n    if(\n      ri!excludeRelatedRecords,\n      {},\n      {\n        recordType!CMGT_Case.status,\n        recordType!CMGT_Case.priority,\n        recordType!CMGT_Case.caseType\n      }\n    ),\n    if(\n      ri!includeAssignees,\n      {\n        recordType!CMGT_Case.roles,\n        recordType!CMGT_Case.roles\n      },\n      {}\n    ),\n    if(\n      ri!includePrimaryContact,\n      {\n        recordType!CMGT_Case.caseEntityMap,\n        #\"urn:appian:record-relationship:v1:d81cdd0e-c54d-4b8e-beec-b7ae37fefe7f/9455b8a8-142d-4976-8b8d-83403eedad6a/043457e2-ee0b-4c7a-8210-8671bbe73128/2a2b64c2-0530-4e0a-a173-d26a396e3cc9\"\n      },\n      {}\n    )\n  },\n  relatedRecordData: {\n    ri!relatedRecordData,\n    if(\n      ri!includePrimaryContact,\n      #\"SYSTEM_SYSRULES_relatedRecordData\"(\n        relationship: recordType!CMGT_Case.caseEntityMap,\n        limit: 1,\n        filters: #\"SYSTEM_SYSRULES_queryFilter\"(\n          field: recordType!CMGT_CaseEntityMap.entity.entityTypeId,\n          operator: \"=\",\n          value: cons!CMGT_REFID_ENTITY_TYPE_CONTACT\n        )\n      ),\n      {}\n    ),\n    if(\n      ri!includeAssignees,\n      #\"SYSTEM_SYSRULES_relatedRecordData\"(\n        relationship: recordType!CMGT_Case.roles,\n        filters: #\"SYSTEM_SYSRULES_queryFilter\"(\n          field: recordType!CMGT_Role.roleTypeId,\n          operator: \"in\",\n          value: {\n            cons!CMGT_REFID_ROLE_TYPE_USER_ASSIGNEE,\n            cons!CMGT_REFID_ROLE_TYPE_GROUP_ASSIGNEE\n          }\n        )\n      ),\n      {}\n    )\n  },\n  pagingInfo: ri!pagingInfo,\n  sort: ri!sort,\n  groupByFields: ri!groupByFields,\n  searchTerm: ri!searchTerm,\n  searchFields: ri!searchFields\n)"
    }
  }
}