{
  "_metadata": {
    "bundle_id": "AIA_Classification_Save_Results"
  },
  "objects": {
    "0009eb88-96d2-8000-fa74-7f0000014e7a": {
      "name": "AIA Classification Save Results",
      "type": "Process Model",
      "sail_code": "// Input: ?\n=pv!ClassificationInstance\n\n// Input: ?\n=recordType!AIA Classification Instance\n\n// Output: ?\nAC!RecordsUpdated\n\n// Output: ?\na!defaultValue(\n  pv!ClassificationInstance[recordType!AIA Classification Instance.modelVersionId],\n  rule!AIA_Classification_GetLatestModelVersionIdByKey(\n    modelKey: pv!modelKey\n  )\n)\n\n// Output: ?\na!defaultValue(pv!currentOutcomeIndex, 1) + 1\n\n// Input: ?\n=pv!ClassificationInstance\n\n// Input: ?\n= rule!AIA_UTIL_Filter( records: pv!ClassificationInstance[recordType!AIA Classification Instance.outcomes], field: recordType!AIA Classification Instance Outcome.outcomeOverride, value: cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_DELETED)\n\n// Output: ?\nrule!AIA_ClassificationInstance_PostProcess(\n  classificationInstance: #\"urn:appian:function:v1:a:update\"(\n    data: rule!AIA_Classification_CreateUpdateInstance(\n      initiator: pp!initiator,\n      responseJson: pv!promptResponse,\n      inputDoc: pv!documentId,\n      modelVersionId: pv!modelVersionId,\n      ClassificationInstance: pv!ClassificationInstance,\n      isReconciliation: pv!isReconciliation\n    ),\n    index: recordType!AIA Classification Instance.outcomes,\n    value: rule!AIA_ClassificationInstance_CreateUpdateInstanceOutcomes(\n      classificationInstance: pv!ClassificationInstance,\n      promptResponse: pv!promptResponse,\n      initiator: pp!initiator\n    )\n  )\n)\n\n// Output: ?\n1\n\n// Input: ?\n=concat( document(pv!ClassificationInstance[recordType!AIA Classification Instance.documentId], \"name\"), \"-\", pv!currentOutcomeIndex)\n\n// Input: ?\n=pv!ClassificationInstance[recordType!AIA Classification Instance.documentFolderId]\n\n// Input: ?\n=pv!ClassificationInstance[recordType!AIA Classification Instance.documentId]\n\n// Input: ?\n= a!localVariables( local!currentOutcome: rule!AIA_UTIL_Filter( records: pv!ClassificationInstance[recordType!AIA Classification Instance.outcomes], field: recordType!AIA Classification Instance Outcome.outcomeOverride, value: { cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_DELETED, cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_REMOVED }, filterType: \"REJECT\" )[pv!currentOutcomeIndex], local!outcomeSplitPagesJson: rule!AIA_ExtractJson( json: a!defaultValue( local!currentOutcome[recordType!AIA Classification Instance Outcome.splitPagesJsonOverride], local!currentOutcome[recordType!AIA Classification Instance Outcome.splitPagesJson] ) ), if( or( a!isNullOrEmpty(local!outcomeSplitPagesJson), a!isNullOrEmpty( tointeger( local!outcomeSplitPagesJson.startPageNumber ) ), tointeger( local!outcomeSplitPagesJson.startPageNumber ) > pv!ClassificationInstance[recordType!AIA Classification Instance.pageCount], tointeger( local!outcomeSplitPagesJson.startPageNumber ) < 0 ), 1, local!outcomeSplitPagesJson.startPageNumber ))\n\n// Input: ?\n= a!localVariables( local!currentOutcome: rule!AIA_UTIL_Filter( records: pv!ClassificationInstance[recordType!AIA Classification Instance.outcomes], field: recordType!AIA Classification Instance Outcome.outcomeOverride, value: { cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_DELETED, cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_REMOVED }, filterType: \"REJECT\" )[pv!currentOutcomeIndex], local!outcomeSplitPagesJson: rule!AIA_ExtractJson( json: a!defaultValue( local!currentOutcome[recordType!AIA Classification Instance Outcome.splitPagesJsonOverride], local!currentOutcome[recordType!AIA Classification Instance Outcome.splitPagesJson] ) ), if( or( a!isNullOrEmpty(local!outcomeSplitPagesJson), a!isNullOrEmpty( tointeger( local!outcomeSplitPagesJson.endPageNumber ) ), tointeger( local!outcomeSplitPagesJson.endPageNumber ) > pv!ClassificationInstance[recordType!AIA Classification Instance.pageCount], tointeger( local!outcomeSplitPagesJson.endPageNumber ) < 0 ), pv!ClassificationInstance[recordType!AIA Classification Instance.pageCount], local!outcomeSplitPagesJson.endPageNumber ))\n\n// Output: ?\nappian:record-relationship:v1:bba819fb-55a0-47e1-bb74-e385f32b6916/39956b9c-96d6-4679-b9b8-9e4abd574abd\"]:#\"urn:appian:function:v1:a:update\"(\n  data: pv!ClassificationInstance[recordType!AIA Classification Instance.outcomes],\n  index: rule!AIA_UTIL_Filter(\n    records: pv!ClassificationInstance[recordType!AIA Classification Instance.outcomes],\n    field: recordType!AIA Classification Instance Outcome.outcomeOverride,\n    value: {\n      cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_DELETED,\n      cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_REMOVED\n    },\n    filterType: \"REJECT_INDICES\"\n  )[pv!currentOutcomeIndex],\n  value: #\"urn:appian:function:v1:a:update\"(\n    data: rule!AIA_UTIL_Filter(\n      records: pv!ClassificationInstance[recordType!AIA Classification Instance.outcomes],\n      field: recordType!AIA Classification Instance Outcome.outcomeOverride,\n      value: {\n        cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_DELETED,\n        cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_REMOVED\n      },\n      filterType: \"REJECT\"\n    )[pv!currentOutcomeIndex],\n    index: {\n      recordType!AIA Classification Instance Outcome.documentId,\n      recordType!AIA Classification Instance Outcome.pageCount\n    },\n    value: {\n      ac!NewDocumentCreated,\n      rule!AIA_GetPageCount(\n        document: ac!NewDocumentCreated\n      )\n    }\n  )\n)\n\n// Input: ?\n/*Ensures that the original instance doc doesn't get moved (new/added Outcomes are initialized with the instance's docId)*/\nrule!AIA_UTIL_Filter(\n  records: pv!ClassificationInstance[recordType!AIA Classification Instance.outcomes],\n  field: recordType!AIA Classification Instance Outcome.documentId,\n  value: pv!ClassificationInstance[recordType!AIA Classification Instance.documentId],\n  filterType: \"REJECT\"\n)[recordType!AIA Classification Instance Outcome.documentId]"
    },
    "_a-0000ee21-294f-8000-9bb6-011c48011c48_184766": {
      "name": "AIA_PLG_WriteFile",
      "type": "Expression Rule",
      "sail_code": "with(\n  local!result: writefile(\n    ri!content,\n    ri!name,\n    ri!extension,\n    ri!folder,\n    ri!description\n  ),\n  if(\n    local!result.success,\n    local!result,\n    fn!error(local!result.error)\n  )\n)"
    },
    "_a-0000ed46-3c8c-8000-9bac-011c48011c48_26889": {
      "name": "AIA_UTIL_Filter",
      "type": "Expression Rule",
      "sail_code": "a!localVariables(\n  local!fieldValuePairs: a!defaultValue(\n    ri!fieldValuePairs,\n    #\"SYSTEM_SYSRULES_forEach\"(\n      items: a!flatten(ri!field),\n      expression: a!map(\n        field: fv!item,\n        value: if(\n          fv!itemCount = 1,\n          ri!value,\n          index(a!flatten(ri!value), fv!index, null)\n        )\n      )\n    )\n  ),\n  local!matchIndices: if(\n    a!isNullOrEmpty(a!flatten(ri!records)),\n    tointeger({}),\n    reduce(\n      rule!AIA_UTIL_Filter_Reducer(\n        previousIndices: _,\n        records: a!flatten(ri!records),\n        fieldValuePair: _\n      ),\n      enumerate(count(a!flatten(ri!records))) + 1,\n      local!fieldValuePairs\n    )\n  ),\n  local!rejectIndices: difference(\n    if(\n      a!isNullOrEmpty(ri!records),\n      tointeger({}),\n      enumerate(count(a!flatten(ri!records))) + 1\n    ),\n    local!matchIndices\n  ),\n  local!matches: cast(\n    runtimetypeof(ri!records),\n    index(ri!records, local!matchIndices, {})\n  ),\n  local!rejects: cast(\n    runtimetypeof(ri!records),\n    index(ri!records, local!rejectIndices, {})\n  ),\n  a!match(\n    value: a!defaultValue(ri!filterType, \"FILTER\"),\n    equals: \"FILTER\",\n    then: local!matches,\n    equals: \"REJECT\",\n    then: local!rejects,\n    equals: \"FIRST_MATCH\",\n    then: index(local!matches, 1, null),\n    equals: \"FIRST_REJECT\",\n    then: index(local!rejects, 1, null),\n    equals: \"MATCH_COUNT\",\n    then: count(local!matchIndices),\n    equals: \"REJECT_COUNT\",\n    then: count(local!rejectIndices),\n    equals: \"MATCH_INDICES\",\n    then: local!matchIndices,\n    equals: \"REJECT_INDICES\",\n    then: local!rejectIndices,\n    equals: \"FULL_RESULT\",\n    then: a!map(\n      matches: local!matches,\n      rejects: local!rejects,\n      firstMatch: index(local!matches, 1, null),\n      firstReject: index(local!rejects, 1, null),\n      matchCount: count(local!matchIndices),\n      rejectCount: count(local!rejectIndices),\n      matchIndices: local!matchIndices,\n      rejectIndices: local!rejectIndices\n    ),\n    default: fn!error(\n      \"Invalid filterType, must be one of: FILTER, REJECT, FIRST_MATCH, FIRST_REJECT, MATCH_COUNT, REJECT_COUNT, MATCH_INDICES, REJECT_INDICES, FULL_RESULT\"\n    )\n  )\n)"
    },
    "_a-0000edb0-f009-8000-9ba8-011c48011c48_97164": {
      "name": "AIA_UTIL_isBlank",
      "type": "Expression Rule",
      "sail_code": "cast(\n  'type!{http://www.appian.com/ae/types/2009}Boolean',\n  length(a!flatten(ri!value)) = 0\n)"
    },
    "_a-0000ef2c-4192-8000-9e56-011c48011c48_353021": {
      "name": "AIA_ClassificationInstanceOutcome_Initialize",
      "type": "Expression Rule",
      "sail_code": "recordType!AIA Classification Instance Outcome(\n  recordType!AIA Classification Instance Outcome.instanceId: ri!classificationInstanceId,\n  recordType!AIA Classification Instance Outcome.modelVersionId: ri!modelVersionId,\n  recordType!AIA Classification Instance Outcome.documentId: ri!documentId,\n  recordType!AIA Classification Instance Outcome.pageCount: ri!pageCount,\n  recordType!AIA Classification Instance Outcome.classification: ri!classification,\n  recordType!AIA Classification Instance Outcome.classificationOverride: ri!classificationOverride,\n  recordType!AIA Classification Instance Outcome.reasoning: ri!reasoning,\n  recordType!AIA Classification Instance Outcome.isSplit: ri!isSplit,\n  recordType!AIA Classification Instance Outcome.splitPagesJson: ri!splitPagesJson,\n  recordType!AIA Classification Instance Outcome.splitPagesJsonOverride: ri!splitPagesJsonOverride,\n  recordType!AIA Classification Instance Outcome.outcomeOverride: ri!outcomeOverride,\n  recordType!AIA Classification Instance Outcome.createdBy: ri!initiator,\n  recordType!AIA Classification Instance Outcome.createdOn: now(),\n  recordType!AIA Classification Instance Outcome.modifiedBy: ri!initiator,\n  recordType!AIA Classification Instance Outcome.modifiedOn: now()\n)"
    },
    "_a-0000eea3-15ee-8000-9bd4-011c48011c48_138762": {
      "name": "AIA_UTIL_SetRecordFields",
      "type": "Expression Rule",
      "sail_code": "/*\nFuture enhancement ideas:\n1 Parameter to skip update if the field isn't present in the object\n--- This would also apply to nested fields, as in, don't set a relationship field if the entire relationship object isn't there because it will instantiate it\n2 Parameter to overwrite based on more enhanced logic\n3 Allow list types for the `value`\n4 Allow reuse to apply setting metadata for nested relationships, but using their own set metadata rule\n--- e.g. CCM_Comment_SetMetaData can be used in both the Claim process and the individual Comment process\n*/\nif(\n  a!isNullOrEmpty(ri!record),\n  ri!record,\n  a!localVariables(\n    local!allUpdates: rule!AIA_UTIL_rejectNullValuesFromArray(a!flatten(\n      {\n        ri!alwaysOverwrite,\n        ri!childRelationships,\n        #\"SYSTEM_SYSRULES_forEach\"(\n          items: ri!neverOverwrite,\n          expression: #\"urn:appian:function:v1:a:update\"(\n            fv!item,\n            \"value\",\n            /*Specifically using this instead of a!defaultValue() to account for the `{null}` value*/\n            if(\n              rule!AIA_UTIL_isBlank(ri!record[fv!item.field]),\n              fv!item.value,\n              ri!record[fv!item.field]\n            )\n          )\n        )\n      }\n    )),\n    local!onlyChangedUpdates: a!flatten(\n      #\"SYSTEM_SYSRULES_forEach\"(\n        items: local!allUpdates,\n        expression: if(\n          or(\n            tostring(ri!record[fv!item.field]) = tostring(fv!item.value),\n            toboolean(fv!item.applyWhen) = false\n          ),\n          {},\n          fv!item\n        )\n      )\n    ),\n    if(\n      a!isNullOrEmpty(local!onlyChangedUpdates),\n      ri!record,\n      #\"urn:appian:function:v1:a:update\"(\n        data: ri!record,\n        index: local!onlyChangedUpdates.field,\n        value: local!onlyChangedUpdates.value\n      )\n    )\n  )\n)"
    },
    "_a-0000ee52-8983-8000-9ba6-011c48011c48_27887": {
      "name": "AIA_GetDocumentMetadata",
      "type": "Expression Rule",
      "sail_code": "try(\n  a!match(\n    value: lower(document(ri!document, \"extension\")),\n    equals: \"pdf\",\n    then: getpdfmetadata(document: ri!document),\n    equals: \"eml\",\n    then: a!map(\n      pageCount: try(\n        tointeger(\n          len(\n            #\"SYSTEM_SYSRULES_fromJson_v1\"(reademlfile(ri!document)).body\n          ) / cons!AIA_EML_PAGE_CHAR_COUNT\n        ),\n        1\n      )\n    ),\n    default: a!map(pageCount: 1)\n  ),\n  a!map(pageCount: 1)\n)"
    },
    "_a-0000ef39-a43c-8000-9ecf-011c48011c48_429114": {
      "name": "AIA_QR_getClassificationModelVersion",
      "type": "Expression Rule",
      "sail_code": "rule!SHRD_UTIL_QueryRecord(\n  recordType: recordType!AIA Classification Model Version,\n  fields: {\n    ri!fields\n  },\n  returnType: ri!returnType,\n  executeWhen: ri!executeWhen,\n  relatedRecordData: ri!relatedRecordData,\n  pagingInfo: ri!pagingInfo,\n  sort: ri!sort,\n  identifier: ri!modelVersionId,\n  filters: {\n    #\"SYSTEM_SYSRULES_queryFilter\"(\n      field: recordType!AIA Classification Model Version.modelVersionId,\n      operator: \"=\",\n      value: ri!modelVersionId\n    ),\n    #\"SYSTEM_SYSRULES_queryFilter\"(\n      field: recordType!AIA Classification Model Version.modelId,\n      operator: \"=\",\n      value: ri!modelId\n    ),\n    #\"SYSTEM_SYSRULES_queryFilter\"(\n      field: recordType!AIA Classification Model Version.status,\n      operator: \"=\",\n      value: ri!status\n    ),\n    #\"SYSTEM_SYSRULES_queryFilter\"(\n      field: recordType!AIA Classification Model Version.model.key,\n      operator: \"=\",\n      value: ri!modelKey\n    ),\n    ri!additionalFilters\n  }\n)"
    },
    "_a-0000ee5d-151c-8000-9ba8-011c48011c48_36163": {
      "name": "SHRD_UTIL_QueryRecord",
      "type": "Expression Rule",
      "sail_code": "a!localVariables(\n  local!maxBatchSize: 5000,\n  /*Chosen return type*/\n  local!returnType: a!defaultValue(ri!returnType, \"OBJECT_ARRAY\"),\n  /*Determine the query parameters to use by the return type*/\n  local!queryParams: a!match(\n    value: local!returnType,\n    equals: \"OBJECT_ARRAY\",\n    then: a!map(\n      castToType: if(\n        a!isNullOrEmpty(ri!groupByFields),\n        #\"urn:appian:function:v1:a:listtype?okey=a!listType\"(ri!recordType),\n        'type!{http://www.appian.com/ae/types/2009}Map?list'\n      ),\n      fetchTotalCount: false,\n      isArray: true,\n      queryRecordByIdentifier: false,\n      pagingInfo: #\"SYSTEM_SYSRULES_pagingInfo\"(\n        startIndex: 1,\n        batchSize: a!defaultValue(\n          ri!pagingInfo.batchSize,\n          local!maxBatchSize\n        ),\n        sort: { ri!pagingInfo.sort, ri!sort }\n      )\n    ),\n    equals: \"SINGLE_OBJECT\",\n    then: a!map(\n      castToType: if(\n        a!isNullOrEmpty(ri!groupByFields),\n        ri!recordType,\n        'type!{http://www.appian.com/ae/types/2009}Map'\n      ),\n      fetchTotalCount: false,\n      isArray: false,\n      queryRecordByIdentifier: false,\n      pagingInfo: #\"SYSTEM_SYSRULES_pagingInfo\"(\n        startIndex: 1,\n        batchSize: 1,\n        sort: { ri!pagingInfo.sort, ri!sort }\n      )\n    ),\n    equals: \"RECORD_BY_ID\",\n    then: a!map(\n      castToType: ri!recordType,\n      fetchTotalCount: false,\n      isArray: false,\n      queryRecordByIdentifier: true,\n      pagingInfo: #\"SYSTEM_SYSRULES_pagingInfo\"(\n        startIndex: 1,\n        batchSize: 1,\n        sort: { ri!pagingInfo.sort, ri!sort }\n      )\n    ),\n    equals: \"DATA_SUBSET\",\n    then: a!map(\n      castToType: 'type!{http://www.appian.com/ae/types/2009}DataSubset',\n      fetchTotalCount: true,\n      isArray: false,\n      queryRecordByIdentifier: false,\n      pagingInfo: #\"SYSTEM_SYSRULES_pagingInfo\"(\n        startIndex: a!defaultValue(ri!pagingInfo.startIndex, 1),\n        batchSize: a!defaultValue(\n          ri!pagingInfo.batchSize,\n          local!maxBatchSize\n        ),\n        sort: { ri!pagingInfo.sort, ri!sort }\n      )\n    ),\n    equals: \"TOTAL_COUNT\",\n    then: a!map(\n      castToType: 'type!{http://www.appian.com/ae/types/2009}Integer',\n      fetchTotalCount: true,\n      isArray: false,\n      queryRecordByIdentifier: false,\n      pagingInfo: #\"SYSTEM_SYSRULES_pagingInfo\"(startIndex: 1, batchSize: 0)\n    ),\n    default: fn!error(\n      \"Invalid returnType, must be one of: OBJECT_ARRAY, SINGLE_OBJECT, RECORD_BY_ID, DATA_SUBSET, TOTAL_COUNT\"\n    )\n  ),\n  if(\n    /*Early exit for skip execution*/\n    ri!executeWhen = false,\n    cast(\n      local!queryParams.castToType,\n      if(local!queryParams.isArray, {}, null)\n    ),\n    a!localVariables(\n      /*Run the query*/\n      local!queryResult: a!refreshVariable(\n        value: if(\n          local!queryParams.queryRecordByIdentifier,\n          #\"SYSTEM_SYSRULES_queryRecordByIdentifier\"(\n            recordType: ri!recordType,\n            identifier: index({ri!identifier},1,null),\n            /*If fields is sent in using a!selectionFields(), then adding the fields contained in ri!relatedRecordData will break the query*/\n            fields: reject(\n              a!isNullOrEmpty,\n              a!flatten(\n                {\n                  ri!fields,\n                  if(\n                    or(\n                      typeof(ri!fields) = typeof(#\"SYSTEM_SYSRULES_selectionFields\"()),\n                      typeof(ri!fields) = typeof({#\"SYSTEM_SYSRULES_selectionFields\"()})\n                    ),\n                    {},\n                    index(ri!relatedRecordData, \"relationship\", {})\n                  )\n                }\n              )\n            ),\n            relatedRecordData: ri!relatedRecordData\n          ),\n          #\"SYSTEM_SYSRULES_queryRecordType_v1\"(\n            recordType: ri!recordType,\n            fields: if(\n              a!isNullOrEmpty(ri!groupByFields),\n              reject(\n                a!isNullOrEmpty,\n                a!flatten(\n                  {\n                    ri!fields,\n                    index(ri!relatedRecordData, \"relationship\", {})\n                  }\n                )\n              ),\n              #\"SYSTEM_SYSRULES_aggregationFields\"(\n                groupings: #\"SYSTEM_SYSRULES_forEach\"(\n                  items: ri!groupByFields,\n                  expression: #\"SYSTEM_SYSRULES_grouping\"(field: fv!item, alias: tostring(fv!item))\n                ),\n                measures: #\"SYSTEM_SYSRULES_measure\"(\n                  field: ri!groupByFields[1],\n                  function: \"COUNT\",\n                  alias: \"count\"\n                )\n              )\n            ),\n            filters: #\"SYSTEM_SYSRULES_queryLogicalExpression\"(\n              operator: \"AND\",\n              ignoreFiltersWithEmptyValues: true,\n              logicalExpressions: {\n                ri!logicalExpressions,\n                if(\n                  and(\n                    a!isNotNullOrEmpty(ri!searchFields),\n                    a!isNotNullOrEmpty(ri!searchTerm)\n                  ),\n                  #\"SYSTEM_SYSRULES_queryLogicalExpression\"(\n                    operator: \"AND\",\n                    logicalExpressions: #\"SYSTEM_SYSRULES_forEach\"(\n                      items: split(trim(ri!searchTerm), \" \"),\n                      expression: a!localVariables(\n                        local!splitSearchTerm: fv!item,\n                        /*   Initiate filter for each field by the value provided in searchTerm   */\n                        #\"SYSTEM_SYSRULES_queryLogicalExpression\"(\n                          operator: \"OR\",\n                          filters: #\"SYSTEM_SYSRULES_forEach\"(\n                            items: ri!searchFields,\n                            expression: #\"SYSTEM_SYSRULES_queryFilter\"(\n                              field: fv!item,\n                              operator: \"includes\",\n                              value: local!splitSearchTerm\n                            )\n                          )\n                        )\n                      )\n                    )\n                  ),\n                  {}\n                )\n              },\n              filters: ri!filters\n            ),\n            pagingInfo: if(\n              a!isNullOrEmpty(ri!groupByFields),\n              local!queryParams.pagingInfo,\n              #\"urn:appian:function:v1:a:update\"(\n                local!queryParams.pagingInfo,\n                \"sort\",\n                null\n              )\n            ),\n            fetchTotalCount: local!queryParams.fetchTotalCount,\n            relatedRecordData: if(\n              a!isNullOrEmpty(ri!groupByFields),\n              ri!relatedRecordData,\n              {}\n            )\n          )\n        ),\n        refreshOnVarChange: ri!triggerRefresh,\n        refreshAfter: { \"RECORD_ACTION\" }\n      ),\n      /*Format the output*/\n      local!output: a!match(\n        value: local!returnType,\n        equals: \"OBJECT_ARRAY\",\n        then: cast(\n          local!queryParams.castToType,\n          index(local!queryResult,\"data\",{})\n        ),\n        equals: \"SINGLE_OBJECT\",\n        then: cast(\n          local!queryParams.castToType,\n          index(local!queryResult,\"data\",{})\n        ),\n        equals: \"RECORD_BY_ID\",\n        /*do not need to cast for queryRecordByIdentifier*/\n        then: local!queryResult,\n        equals: \"DATA_SUBSET\",\n        then: cast(\n          local!queryParams.castToType,\n          local!queryResult\n        ),\n        equals: \"TOTAL_COUNT\",\n        then: cast(\n          local!queryParams.castToType,\n          index(local!queryResult,\"totalCount\",{})\n        ),\n        default: null\n      ),\n      local!output\n    )\n  )\n)"
    },
    "_a-0000ec44-cb49-8000-9be6-011c48011c48_82400": {
      "name": "AIA_GetPageCount",
      "type": "Expression Rule",
      "sail_code": "rule!AIA_GetDocumentMetadata(\n  document: ri!document\n).pageCount"
    },
    "_a-0000ec5c-9eda-8000-9bec-011c48011c48_119664": {
      "name": "AIA_Classification_GetLatestModelVersionIdByKey",
      "type": "Expression Rule",
      "sail_code": "index(\n  rule!AIA_QR_getClassificationModelVersion(\n    returnType: \"SINGLE_OBJECT\",\n    fields: {\n      recordType!AIA Classification Model Version.modelVersionId\n    },\n    modelKey: ri!modelKey,\n    modelId: ri!modelId,\n    status: cons!AIA_MODEL_VERSION_STATUS_PUBLISHED,\n    sort: #\"SYSTEM_SYSRULES_sortInfo\"(\n      field: recordType!AIA Classification Model Version.versionId,\n      ascending: false\n    )\n  ),\n  recordType!AIA Classification Model Version.modelVersionId,\n  tointeger(null)\n)"
    },
    "_a-0000ec2d-5396-8000-9bdc-011c48011c48_40909": {
      "name": "AIA_ExtractJson",
      "type": "Expression Rule",
      "sail_code": "a!localVariables(\n  local!firstTry: rule!AIA_ExtractJsonInner(\n    json: ri!json\n  ),\n  local!result: if(\n    a!isNotNullOrEmpty(local!firstTry),\n    local!firstTry,\n    a!localVariables(\n      local!secondTry: rule!AIA_ExtractJsonInner(\n        json: index(split(ri!json, \"Appian's private AI\"), 1, null),\n      ),\n      if(\n        a!isNotNullOrEmpty(local!secondTry),\n        local!secondTry,\n        a!localVariables(\n          local!thirdTry: rule!AIA_ExtractJsonInner(\n            json: index(split(ri!json, \"Appian's private AI\"), 2, null),\n          ),\n          if(\n            a!isNotNullOrEmpty(local!thirdTry),\n            local!thirdTry,\n            a!localVariables(\n              local!forthTry: rule!AIA_ExtractJsonInner(\n                json: index(split(ri!json, \"<output>\"), 1, null),\n              ),\n              if(\n                a!isNotNullOrEmpty(local!forthTry),\n                local!forthTry,\n                a!localVariables(\n                  local!fifthTry: rule!AIA_ExtractJsonInner(\n                    json: index(split(ri!json, \"</entities>\"), 1, null),\n                  ),\n                  local!fifthTry\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  ),\n  local!finalResult: if(\n    a!isNullOrEmpty(local!result),\n    null,\n    if(\n      a!defaultValue(ri!returnList, true),\n      local!result,\n      if(\n        rule!SHRD_IsList(local!result),\n        null,\n        local!result\n      )\n    )\n  ),\n  /* Handle scenario where the result comes back as properties of a $schema */\n  if(\n    or(\n      a!defaultValue(ri!returnList, true),\n      a!isNullOrEmpty(local!finalResult),\n      not(contains(\n        a!keys(local!finalResult),\n        \"$schema\"\n      ))\n    ),\n    local!finalResult,\n    local!finalResult.properties\n  )\n)"
    },
    "_a-0000ef2c-4192-8000-9e56-011c48011c48_353033": {
      "name": "AIA_ClassificationInstance_CreateUpdateInstanceOutcomes",
      "type": "Expression Rule",
      "sail_code": "if(\n  a!isNullOrEmpty(ri!classificationInstance[recordType!AIA Classification Instance.outcomes]),\n  /*Create New Outcomes based on Prompt Response*/\n  a!localVariables(\n    local!promptResponseJson: rule!AIA_ExtractJson(json: ri!promptResponse),\n    /*If the prompt response is totally empty OR the prompt response converted to JSON is empty, then we can just use ri!promptResponse for the classification of the document*/\n    /*A null local!promptResponseJson indicates an older version of Classification was used in which the response is just a plain text string with the chosen classification option*/\n    if(\n      or(\n        a!isNullOrEmpty(ri!promptResponse),\n        a!isNullOrEmpty(local!promptResponseJson)\n      ),\n      rule!AIA_ClassificationInstanceOutcome_Initialize(\n        classificationInstanceId: ri!classificationInstance[recordType!AIA Classification Instance.id],\n        modelVersionId: ri!classificationInstance[recordType!AIA Classification Instance.modelVersionId],\n        documentId: ri!classificationInstance[recordType!AIA Classification Instance.documentId],\n        pageCount: ri!classificationInstance[recordType!AIA Classification Instance.pageCount],\n        classification: ri!promptResponse,\n        reasoning: null,\n        isSplit: false,\n        splitPagesJson: null,\n        initiator: ri!initiator\n      ),\n      /*Otherwise, the prompt response is a valid JSON response that could include either a single dictionary or list of dictionary.*/\n      /*Either way, we can loop over the response and construct an Outcome*/\n      #\"SYSTEM_SYSRULES_forEach\"(\n        items: local!promptResponseJson,\n        expression: rule!AIA_ClassificationInstanceOutcome_Initialize(\n          classificationInstanceId: ri!classificationInstance[recordType!AIA Classification Instance.id],\n          modelVersionId: ri!classificationInstance[recordType!AIA Classification Instance.modelVersionId],\n          documentId: ri!classificationInstance[recordType!AIA Classification Instance.documentId],\n          pageCount: ri!classificationInstance[recordType!AIA Classification Instance.pageCount],\n          classification: fv!item.classification,\n          reasoning: fv!item.reasoning,\n          isSplit: length(local!promptResponseJson) > 1,\n          splitPagesJson: if(\n            ri!classificationInstance[recordType!AIA Classification Instance.modelVersion.allowMultipleOutputs] = true,\n            #\"SYSTEM_SYSRULES_toJson_v1\"(\n              a!map(\n                splitType: fv!item.splitType,\n                startPageNumber: fv!item.startPageNumber,\n                endPageNumber: fv!item.endPageNumber\n              )\n            ),\n            null\n          ),\n          initiator: ri!initiator\n        )\n      )\n    )\n  ),\n  /*Update Existing Outcomes' Metadata*/\n  rule!AIA_UTIL_SetRecordFields(\n    record: ri!classificationInstance[recordType!AIA Classification Instance.outcomes],\n    alwaysOverwrite: {\n      a!map(\n        field: recordType!AIA Classification Instance Outcome.modifiedBy,\n        value: ri!initiator\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance Outcome.modifiedOn,\n        value: now()\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance Outcome.isSplit,\n        value: rule!AIA_UTIL_Filter(\n          records: ri!classificationInstance[recordType!AIA Classification Instance.outcomes],\n          field: recordType!AIA Classification Instance Outcome.outcomeOverride,\n          value: {\n            cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_DELETED,\n            cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_REMOVED\n          },\n          filterType: \"REJECT_COUNT\"\n        ) > 1\n      )\n    }\n  )\n)"
    },
    "_a-0000edb0-f009-8000-9ba8-011c48011c48_97176": {
      "name": "AIA_UTIL_rejectNullValuesFromArray",
      "type": "Expression Rule",
      "sail_code": "cast(\n  typeof(ri!array),\n  reject(\n    rule!AIA_UTIL_isBlank(_),\n    a!flatten(ri!array)\n  )\n)"
    },
    "_a-0000ef3f-73a8-8000-9f8e-011c48011c48_454830": {
      "name": "AIA_ClassificationInstance_PostProcess",
      "type": "Expression Rule",
      "sail_code": "a!localVariables(\n  /*All non-deleted outcomes will serve as the denominator in the calculation for accuracy as this represents the number of correct outcomes + the number of incorrect outcomes*/\n  local!nonDeletedOutcomes: rule!AIA_UTIL_Filter(\n    records: ri!classificationInstance[recordType!AIA Classification Instance.outcomes],\n    field: recordType!AIA Classification Instance Outcome.outcomeOverride,\n    value: cons!AIA_TXT_CLASSIFICATION_OUTCOME_OVERRIDE_DELETED,\n    filterType: \"REJECT\"\n  ),\n  local!correctOutcomes: rule!AIA_UTIL_rejectNullValuesFromArray(\n    #\"SYSTEM_SYSRULES_forEach\"(\n      items: local!nonDeletedOutcomes,\n      expression: if(\n        and(\n          a!isNullOrEmpty(fv!item[recordType!AIA Classification Instance Outcome.classificationOverride]),\n          a!isNullOrEmpty(fv!item[recordType!AIA Classification Instance Outcome.splitPagesJsonOverride]),\n          a!isNullOrEmpty(fv!item[recordType!AIA Classification Instance Outcome.outcomeOverride])\n        ),\n        fv!item,\n        null\n      )\n    )\n  ),\n  #\"urn:appian:function:v1:a:update\"(\n    data: ri!classificationInstance,\n    index: recordType!AIA Classification Instance.accuracy,\n    value: length(local!correctOutcomes) / length(local!nonDeletedOutcomes)\n  )\n)"
    },
    "_a-0000ec67-5f00-8000-9bf0-011c48011c48_125297": {
      "name": "AIA_Classification_CreateUpdateInstance",
      "type": "Expression Rule",
      "sail_code": "a!localVariables(\n  local!isStatusEmpty: a!isNullOrEmpty(\n    ri!ClassificationInstance[recordType!AIA Classification Instance.statusId]\n  ),\n  local!statusId: tointeger(if(\n    local!isStatusEmpty,\n    cons!AIA_INSTANCE_STATUS_INITIATED,\n    a!match(\n      value: ri!ClassificationInstance[recordType!AIA Classification Instance.statusId],\n      equals: cons!AIA_INSTANCE_STATUS_RECONCILED_MANUALLY,\n      equals: cons!AIA_INSTANCE_STATUS_RECONCILED_AUTOMATICALLY,\n      equals: cons!AIA_INSTANCE_STATUS_CLASSIFIED,\n      then: fv!value,\n      whenTrue: and(\n        or(\n          fv!value = cons!AIA_INSTANCE_STATUS_INITIATED,\n          a!isNullOrEmpty(fv!value)\n        ),\n        a!isNotNullOrEmpty(ri!responseJson)\n      ),\n      then: cons!AIA_INSTANCE_STATUS_CLASSIFIED,\n      default: fv!value\n    )\n  )),\n  rule!AIA_UTIL_SetRecordFields(\n    record: a!defaultValue(\n      value: ri!ClassificationInstance,\n      default: recordType!AIA Classification Instance()\n    ),\n    neverOverwrite: {\n      a!map(\n        field: recordType!AIA Classification Instance.documentId,\n        value: ri!convertedDoc\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.sourceDocumentId,\n        value: ri!inputDoc\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.inputText,\n        value: ri!inputText\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.modelVersionId,\n        value: ri!modelVersionId\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.createdOn,\n        value: now()\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.createdBy,\n        value: ri!initiator\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.pageCount,\n        applyWhen: or(\n          a!isNotNullOrEmpty(ri!ClassificationInstance[recordType!AIA Classification Instance.documentId]),\n          a!isNotNullOrEmpty(ri!convertedDoc)\n        ),\n        value: rule!AIA_GetPageCount(\n          document: a!defaultValue(\n            ri!ClassificationInstance[recordType!AIA Classification Instance.documentId],\n            ri!convertedDoc\n          )\n        )\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.responseDocumentId,\n        value: if(\n          a!isNullOrEmpty(ri!responseJson),\n          null,\n          rule!AIA_PLG_WriteFile(\n            content: ri!responseJson,\n            name: \"response\",\n            extension: \"json\",\n            folder: ri!ClassificationInstance[recordType!AIA Classification Instance.documentFolderId]\n          ).document\n        )\n      )\n    },\n    alwaysOverwrite: {\n      a!map(\n        field: recordType!AIA Classification Instance.modifiedOn,\n        value: now()\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.modifiedBy,\n        value: ri!initiator\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.reconciledBy,\n        value: if(\n          local!isStatusEmpty,\n          null,\n          if(\n            contains(\n              {\n                cons!AIA_INSTANCE_STATUS_RECONCILED_AUTOMATICALLY,\n                cons!AIA_INSTANCE_STATUS_RECONCILED_MANUALLY\n              },\n              local!statusId\n            ),\n            a!defaultValue(\n              ri!ClassificationInstance[recordType!AIA Classification Instance.reconciledBy],\n              ri!initiator\n            ),\n            \"\"\n          )\n        )\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.reconciledOn,\n        value: if(\n          local!isStatusEmpty,\n          null,\n          if(\n            contains(\n              {\n                cons!AIA_INSTANCE_STATUS_RECONCILED_AUTOMATICALLY,\n                cons!AIA_INSTANCE_STATUS_RECONCILED_MANUALLY\n              },\n              local!statusId\n            ),\n            a!defaultValue(\n              ri!ClassificationInstance[recordType!AIA Classification Instance.reconciledOn],\n              now()\n            ),\n            \"\"\n          )\n        )\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.testInstance,\n        value: a!defaultValue(\n          if(\n            a!isNullOrEmpty(ri!isDocumentTestCase),\n            ri!ClassificationInstance[recordType!AIA Classification Instance.testInstance],\n            ri!isDocumentTestCase\n          ),\n          false()\n        )\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.statusId,\n        value: local!statusId\n      ),\n      a!map(\n        field: recordType!AIA Classification Instance.isSamplingRequired,\n        value: false,\n        applyWhen: ri!isReconciliation = true()\n      )\n    }\n  )\n)"
    }
  }
}