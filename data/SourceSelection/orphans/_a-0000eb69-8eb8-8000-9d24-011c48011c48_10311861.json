{
  "uuid": "_a-0000eb69-8eb8-8000-9d24-011c48011c48_10311861",
  "name": "AS_GSS_UT_queryEntityWithSelection",
  "type": "Expression Rule",
  "description": "Generic query entity with query selection (So that huge load can be avoided while querying)",
  "sail_code": "/*PLEASE REFER TO THE BOTTOM OF THIS RULE FOR INSTRUCTIONS ON HOW TO USE*/\n/**/\n/*Please DO NOT auto-format this rule*/\n/**/\n/**/\n/*Error handling for invalid returnType or entityType*/\nif(\n  a!isNullOrEmpty(ri!returnType),\n  fn!error(\n    concat(\n      \"Null `returnType` passed to AS_GSS_UT_queryEntityWithSelection for entityType `\",\n      ri!entityType,\n      \"`.  See documentation in AS_GSS_UT_queryEntityWithSelection for further information on how to use this parameter.\"\n    )\n  ),\n  not(\n    contains(\n      rule!AS_CO_CONS_QE_RETURN_TYPES(),\n      ri!returnType\n    )\n  ),\n  fn!error(\n    concat(\n      \"Unknown `returnType` passed to AS_GSS_UT_queryEntityWithSelection for entityType `\",\n      ri!entityType,\n      \"`.  See documentation in AS_GSS_UT_queryEntityWithSelection for further information on how to use this parameter.\"\n    )\n  ),\n  a!isNullOrEmpty(ri!entityType),\n  fn!error(\n    concat(\n      \"Null `entityType` passed to AS_GSS_UT_queryEntityWithSelection for entity `\",\n      ri!entity,\n      \"`.  See documentation in AS_GSS_UT_queryEntityWithSelection for further information on how to use this parameter.\"\n    )\n  ),\n  and(\n    ri!returnType = cons!AS_CO_ENUM_QE_RETURN_TYPE_DATA_SUBSET,\n    a!isNullOrEmpty(ri!pagingInfo)\n  ),\n  fn!error(\n    concat(\n      \"`pagingInfo` is required (cannot be null) for `returnType` DATA_SUBSET\"\n    )\n  ),\n  and(\n    ri!returnType <> cons!AS_CO_ENUM_QE_RETURN_TYPE_DATA_SUBSET,\n    a!isNotNullOrEmpty(ri!pagingInfo)\n  ),\n  fn!error(\n    concat(\n      \"`pagingInfo` must be null when the `returnType` is not DATA_SUBSET, instead use `sort` to pass custom-sorting and `startIndex` & `batchSize` will be automatically calculated for you\"\n    )\n  ),\n  and(\n    ri!returnType = cons!AS_CO_ENUM_QE_RETURN_TYPE_AGGREGATION,\n    a!isNullOrEmpty(ri!aggregation)\n  ),\n  fn!error(\n    \"You must provide an input for `aggregation` when `returnType` is AGGREGATION\"\n  ),\n  and(\n    ri!returnType <> cons!AS_CO_ENUM_QE_RETURN_TYPE_AGGREGATION,\n    a!isNotNullOrEmpty(ri!aggregation)\n  ),\n  fn!error(\n    \"You cannot provide an input for `aggregation` when `returnType` is not AGGREGATION\"\n  ),\n  a!localVariables(\n    /*Determine the castResultToType*/\n    local!castResultToType: displayvalue(\n      ri!returnType,\n      rule!AS_CO_CONS_QE_RETURN_TYPES(),\n      {\n        /*DATA_SUBSET*/'type!{http://www.appian.com/ae/types/2009}DataSubset',\n        /*SINGLE_OBJECT*/ri!entityType,\n        /*OBJECT_ARRAY*/typeof(a!flatten(null(ri!entityType))),\n        /*AGGREGATION*/'type!{http://www.appian.com/ae/types/2009}Map?list',\n        /*TOTAL_COUNT*/'type!{http://www.appian.com/ae/types/2009}Integer',\n        \n      },\n      null\n    ),\n    /*Determine the batchSize*/\n    local!batchSize: displayvalue(\n      ri!returnType,\n      rule!AS_CO_CONS_QE_RETURN_TYPES(),\n      {\n        /*DATA_SUBSET*/ri!pagingInfo.batchSize,\n        /*SINGLE_OBJECT*/1,\n        a!defaultValue(\n          value: ri!pagingInfo.batchSize,\n          default: cons!AS_CO_INT_QUERY_MAX_BATCH_SIZE\n        ),\n        /*AGGREGATION*/cons!AS_CO_INT_QUERY_MAX_BATCH_SIZE,\n        /*TOTAL_COUNT*/0,\n        \n      },\n      null\n    ),\n    /*Determine the sort*/\n    local!sort: rule!AS_CO_UT_zInternal_queryEntity_determineSort(\n      entityType: ri!entityType,\n      returnType: ri!returnType,\n      pagingInfo: ri!pagingInfo,\n      sort: ri!sort,\n      isAggregation: a!isNotNullOrEmpty(ri!aggregation)\n    ),\n    /*Determine the pagingInfo*/\n    local!pagingInfo: if(\n      ri!returnType = cons!AS_CO_ENUM_QE_RETURN_TYPE_DATA_SUBSET,\n      /*Use specific pagingInfo for DATA_SUBSET*/\n      #\"SYSTEM_SYSRULES_pagingInfo\"(\n        startIndex: ri!pagingInfo.startIndex,\n        batchSize: ri!pagingInfo.batchSize,\n        sort: local!sort\n      ),\n      /*Otherwise calculate pagingInfo for all other returnTypes*/\n      #\"SYSTEM_SYSRULES_pagingInfo\"(\n        startIndex: 1,\n        batchSize: local!batchSize,\n        sort: local!sort\n      )\n    ),\n    /*Determine the fetchTotalCount*/\n    local!fetchTotalCount: displayvalue(\n      ri!returnType,\n      rule!AS_CO_CONS_QE_RETURN_TYPES(),\n      {\n        /*DATA_SUBSET*/true,\n        /*SINGLE_OBJECT*/false,\n        /*OBJECT_ARRAY*/false,\n        /*AGGREGATION*/false,\n        /*TOTAL_COUNT*/true,\n        \n      },\n      null\n    ),\n    /*Execute the query*/\n    local!queryResult: a!refreshVariable(\n      value: if(\n        ri!executeWhen = false,\n        null,\n        #\"SYSTEM_SYSRULES_queryEntity_v2\"(\n          fetchTotalCount: local!fetchTotalCount,\n          entity: ri!entity,\n          query: #\"SYSTEM_SYSRULES_query\"(\n            pagingInfo: local!pagingInfo,\n            logicalExpression: #\"SYSTEM_SYSRULES_queryLogicalExpression\"(\n              operator: \"AND\",\n              logicalexpressions: {\n                #\"SYSTEM_SYSRULES_queryLogicalExpression\"(\n                  operator: \"AND\",\n                  ignoreFiltersWithEmptyValues: true,\n                  filters: a!defaultValue(value: ri!filters, default: {})\n                ),\n                a!defaultValue(value: ri!logicalExpression, default: {})\n              }\n            ),\n            selection: if(\n              a!isNullOrEmpty(ri!selectionColumns),\n              {},\n              #\"SYSTEM_SYSRULES_querySelection\"(\n                columns: #\"SYSTEM_SYSRULES_forEach\"(\n                  items: ri!selectionColumns,\n                  expression: #\"SYSTEM_SYSRULES_queryColumn\"(field: fv!item)\n                )\n              )\n            )\n          ),\n          fetchtotalcount: true\n        )\n      ),\n      refreshOnVarChange: ri!triggerRefresh,\n      refreshAfter: { \"RECORD_ACTION\" }\n    ),\n    /*Parse the queryResult*/\n    local!queryResultParse: choose(\n      wherecontains(\n        ri!returnType,\n        rule!AS_CO_CONS_QE_RETURN_TYPES()\n      ),\n      /*DATA_SUBSET*/\n      if(\n        a!isNullOrEmpty(local!queryResult.data),\n        local!queryResult.data,\n        #\"urn:appian:function:v1:a:update\"(\n          data: local!queryResult,\n          index: \"data\",\n          value: cast(\n            typeof(a!flatten(null(ri!entityType))),\n            local!queryResult.data\n          )\n        )\n      ),\n      /*SINGLE_OBJECT*/local!queryResult.data,\n      /*OBJECT_ARRAY*/local!queryResult.data,\n      /*AGGREGATION*/local!queryResult.data,\n      /*TOTAL_COUNT*/local!queryResult.totalCount\n    ),\n    rule!AS_CO_UT_cast(\n      type: local!castResultToType,\n      value: local!queryResultParse\n    )\n  )\n)/*\n\nDOCUMENTATION\n\nThis rule is designed to minimize the overhead with querying data and then casting the result\n\n\nRequired Inputs:\n\n1. entity \n- This is the data store entity you are querying\n-- e.g. cons!AS_DATA_STORE_ENTITY_CASES\n\n2. entityType\n- This is a type! input of the data type which maps to the underlying data store entity\n- Note that your type! input should not end in parenthesis; this is NOT designed to take in an empty CDT\n-- e.g. 'type!{urn:com:appian:types}Case'\n\n3. returnType\n- This depends on the purpose for the query, and should be one of the returnTypes in rule!AS_RM_CONS_QE_RETURN_TYPES\n-- DATA_SUBSET - This will return a DataSubset; pagingInfo is required\n-- SINGLE_OBJECT - This will return a single CDT whose type is the entityType; pagingInfo must be null\n-- ARRAY_OBJECT - This will return an array of CDTs whos type is an array of the entityType; pagingInfo must be null\n-- AGGREGATION - This will return an array of Dictionaries; pagingInfo must be null\n---- NOTE: If you need Aggregation with paging controls, such as for a grid, use returnType DATA_SUBSET\n-- TOTAL_COUNT - This will return an Integer of the total count; pagingInfo must be null\n\n\nOptional Inputs:\n\n4. executeWhen\n- The query will not execute if this is false, the query will execute if this is true or null\n-- This is meant to operate in a similar manner to the showWhen parameter of components\n- Use this to skip execution of a query without needing to wrap if() statements around the rule\n-- Examples of this would be to skip querying if your filter value is a null ID\n- If the query does not execute, this will return a null value whose type is based on the returnType input\n\n5. triggerRefresh\n- By default, the query will always re-execute whenever any inputs change\n- However, by updating the value of triggerRefresh, you can also trigger a re-execution even if none of the other inputs change\n\n6. excludeNestedCdts\n- When true, this will exclude all nested CDTs from the query selection, and only include primitive fields\n- When false or null, all fields will be included in the query, including all nested CDTs\n\n7. filters\n- Array of filters to apply to the query, built with a!queryFilter()\n- These filters will be applied with an AND operator\n- These filters will apply in addition to the logicalExpression input, combining both with an AND operator\n\n8. logicalExpression\n- A logical expression to apply to the query, built with a!queryLogicalExpression()\n- This logical expression will apply in addition to the filters input, combining both with an AND operator\n\n9. aggregation\n- Aggregation to apply to the query, built with a!queryAggregation()\n\n10. pagingInfo\n- Paging info to apply to the query, built with a!pagingInfo() or derived from fv!pagingInfo in grids\n- This is required if passing returnType DATA_SUBSET, otherwise it must be null\n- For returnTypes that are not DATA_SUBSET, the batch size will be automatically calculated depending on the returnType\n-- For example, passing SINGLE_OBJECT will automatically apply a batch size of 1, whereas ARRAY_OBJECT and AGGREGATION will automatically apply a batch size of -1\n\n11. sort\n- Array of sort to apply to the query, built with a!sortInfo()\n- This is meant to be used with returnType ARRAY_OBJECT and AGGREGATION, since pagingInfo is not required for these, but a specified sort may be used\n- If both sort and pagingInfo.sort are passed with valid values, they will be applied in conjuction, with the sort parameter being the primary sort\n\n*/",
  "calls": [
    {
      "name": "AS_CO_CONS_QE_RETURN_TYPES",
      "type": "Expression Rule",
      "dep_type": "CALLS"
    },
    {
      "name": "AS_CO_UT_zInternal_queryEntity_determineSort",
      "type": "Expression Rule",
      "dep_type": "CALLS"
    },
    {
      "name": "AS_CO_UT_cast",
      "type": "Expression Rule",
      "dep_type": "CALLS"
    },
    {
      "name": "AS_CO_ENUM_QE_RETURN_TYPE_DATA_SUBSET",
      "type": "Constant",
      "dep_type": "USES_CONSTANT"
    },
    {
      "name": "AS_CO_ENUM_QE_RETURN_TYPE_AGGREGATION",
      "type": "Constant",
      "dep_type": "USES_CONSTANT"
    },
    {
      "name": "AS_CO_INT_QUERY_MAX_BATCH_SIZE",
      "type": "Constant",
      "dep_type": "USES_CONSTANT"
    },
    {
      "name": "AS_CO_ENUM_QE_RETURN_TYPE_SINGLE_OBJECT",
      "type": "Constant",
      "dep_type": "USES_CONSTANT"
    },
    {
      "name": "AS_CO_ENUM_QE_RETURN_TYPE_OBJECT_ARRAY",
      "type": "Constant",
      "dep_type": "USES_CONSTANT"
    },
    {
      "name": "AS_CO_ENUM_QE_RETURN_TYPE_TOTAL_COUNT",
      "type": "Constant",
      "dep_type": "USES_CONSTANT"
    }
  ],
  "called_by": [
    {
      "name": "AS_GSS_QE_getEvaluationCriteriaWithSelection",
      "type": "Expression Rule",
      "dep_type": "CALLS"
    },
    {
      "name": "AS_GSS_TMG_QE_getRuntimeTaskWithSelection",
      "type": "Expression Rule",
      "dep_type": "CALLS"
    }
  ]
}